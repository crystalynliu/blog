---

title: 我所知道的 D3
date: 2019-01-09
categories: 技术.改变生活
tags: [技术, 前端, 图形显示]

---

说起来当代社会有一个流行词语叫做**可视化**，以前我们是用纸笔，印刷技术来完成文字，数据的可视化。到了大数据井喷，人人都开始使用电子设备获取信息的时代，就需要使用技术来实现文字，数据的可视化。而在数据可视化，最直观最有价值的体现就是**使用图表的方式来展现**。

而我是一个前端 developer, 这里记录下来的是，我使用`D3.js`的去开发一个数据可视化界面设计中了解到的 D3。

<!--more-->

# Introduction

## 什么是D3?

先来看看官方解释：
>D3 (or D3.js) is a JavaScript library for visualizing data using web standards. D3 helps you bring data to life using SVG, Canvas and HTML. D3 combines powerful visualization and interaction techniques with a data-driven approach to DOM manipulation, giving you the full capabilities of modern browsers and the freedom to design the right visual interface for your data.

看着是不是一脸懵😳。我大概先翻译一下，之后可以详细解释，官方发言说：

D3 是一个遵循现有的`web`标准上基于数据来操作 HTML DOM（Document Object Model）的 JavaScript 函数库（当然如果你不知道什么叫做 JavaScript，那你就可以关掉这篇文章了。），D3 用 SVG, Canvas 以及 HTML 把展示数据。D3 结合强大的可视化数据驱动技术来驱动 DOM 操作 ，给你强大的能力以及自由针对你的数据去设计更好的可视化界面。

了解过官方的定义之后，再来通俗的给大家一个解释。

D3的全称是 **Data Driven Documents**。懂点英语的都可以直译：数据驱动文档。其实简单来说，就是一个 JavaScript 的函数库，是用来在不借助任何框架的情况下，帮助你在现代浏览器里画出你想要的数据图表。


D3 是一个开源项目，托管于大家耳熟能详的 Github, 目前 **Most stars 排名第8**, 可以看出这是个非常之受欢迎的函数库。但是，当你真正的打开它, 你可能会被非常长的 [API document](https://github.com/d3/d3/blob/master/API.md) 吓倒，或者被它成堆的 [tutorials](https://github.com/d3/d3/wiki) 弄的疲惫不堪。但是不要担心，只要你了解到 D3 本质的优势，就可以很快的上手去完成它。

## D3 的优势
* 它是一个 jQuery like api 的函数库，有前端基础的同学可以很容易使用它的 api 以及链式操作
* 它跟市面上的图形库相比，类似于`Echarts`，更加的灵活，可以给 UX 更大的发挥空间

再接下来的章节中，我们会讲解一些 D3 的主要概念以及实际使用中的问题。

# Basic Conception

## Canvas
使用 D3 画图大部分都是一些不规则的形状，这些形状用 DOM 元素是难以实现的。所以 HTML5 提供了两种强有力的画布：**SVG** 和 **Canvas**, 但是由于 D3 本身提供了众多 SVG 图形生成器，并且本身 svg 是支持 JavaScript 事件处理的。所以一般在选择**画布**时，会使用 SVG 元素。

## Selection and binding Data

D3 被称作为*数据驱动文档*，最重要的一点是利用它的 API, 可以将数据绑定到 DOM 上（也就是文档），就是说针对某一个数据，我们就可以操作它绑定上的相对应的 DOM。

### Selection

D3 的选择器类似于 jQuery 的选择器，都是使用`CSS3`来选择页面的元素，可以使用的选择方式包括

* 标签（"div")
* 类（".awesome")
* Id ("#id")
* 属性 ("[color=red]")

以及更多的联合选择器以及伪选择器。它提供了两种高级方法来选择元素：

* `select()` ： 只返回第一个匹配的元素, 接收的参数可以是一个选择器字符串，也可以是一个节点
* `selectAll()`：选择在文档中遍历所有匹配的元素。接受的参数既可以是选择器字符串，也可以是一个节点（node) list。

有经验的同学都知道选择器可以用来修改 Dom 的一些属性和样式，所以会一般给一些常量来修改属性或者样式，例如：

```
select("p").style("color", "white")
```
但在 D3 中，属性和样式可以被指定为数据中的函数，并不仅仅只是简单的常量，例如：

```
selectAll("p").style("color", function() {
	return "hsl(" + Math.random() * 360 + ",100%,50%";
});	
```

### Binding Data
D3 最基础的功能，也是最特殊的一点就是可以将数据动态的绑定到节点元素中。先来看一段数据绑定的代码：

```
d3.selectAll("p")
  .data([4, 8, 15, 16, 23, 42])
  .style("font-size", function(d) { return d + "px"; });
```

上面这段代码中，数据被指定为一个数组，每个元素作为一个参数传递到函数中，在没有绑定 `key` 的情况下，默认是按照索引的顺序进行传递。上面这段代码的执行结果就是 **段落的字体大小会按照数组中的这些数字来一次显示**。

D3 中是通过以下两个函数来绑定数据的，使用方式跟上面的示例代码相似

* datum(): 绑定一个数据到选择集上
* data(): 绑定一组数据到选择集上，数组的各项值分别于选择集的各元素绑定

### Enter-Update-Exit

* update: **返回一个已经被图形化的节点集合**，然后可以对选择出的集合进行操作和更新。

```
const p = d3.select("body")
  .selectAll("p")
  .data([4, 8, 15, 16, 23, 42])
  .text(function(d) { return d; });
```

上面的例子中，body 中如果已经有3个 p 元素，那就会针对这 3个 p 元素进行 text() 的操作。剩余的数据会保存起来。

* enter()：这个函数操作的意义是**返回一个未被可视化的数据的集合**。

```
p.enter().append("p")
 .text(function(d) { return d; })
```

上面的例子中，会根据剩余的数据创建对应的 p 元素，并将它们按顺序追加到 body 中。

* exit(): **返回没有数据相对应的 DOM 元素**

```
p.exit().remove()
```

## Scale
最最重要的一个概念，就是 Scale（比例尺），通俗点说就是**映射抽象的数据值（比如数字，日期，类别）到可视量化的变量（例如位置，长度，颜色等）**。有了比例尺的出现，可以极大的简化从数据维度到可视化展示的映射。

D3 大约有12种不同的比例尺类型（scaleLinear, scalePow, scalePoint, scaleTime 等），总体来说可以分为3类：

* 连续型输入输出
* 离散性输入连续性输出
* 离散性输入输出

我将列出一些对应类别中常用的 scale 函数进行介绍。

### ScaleLinear
scaleLinear是典型的连续性输入输出函数，为**把连续地输入域映射到连续的输出范围**，提供了良好的缺省选择。例如下面的代码，我们创建一个线性比例尺函数

```
const linearScale = d3.scaleLinear()
	.domain([1, 5])
	.range([0, 100])
```
根据scale 函数，我们可以得到以下的映射关系：
 
 ![](/images/scaleLinear.png)

这时候，我们可以得出 

```
linearScale(1); //return 0
linearScale(4); //return 75
```

作为连续性输入输出类型的比例尺函数，最大的特点就是**输入可以使用`domain`区域外面的数据, 并且根据映射关系输出正确的数据**。参考[API](https://github.com/d3/d3-scale/blob/master/README.md#scaleLinear)。

```
linearScale(-1); //return -50
```

### ScaleBand
`scaleBand()`并不是一个连续性的比例尺，`domain()`作为输入域会要求使用一个数组，但是`range()`确需要一个连续的输出域。它会**把连续输出范围按照输入域的个数进行分割，并且计算出每个 band 的位置和宽度**。

```
const bandScale = d3.scaleBand()
	.domain([1, 2, 3, 4])
	.range([0, 100]);
```

映射函数关系为下图的：

 ![](/images/scaleBand.png)

给一定的数据可以得到：

```
bandScale(1); //return 0
bandScale(4); //return 75
```

对应连续性 scale 函数，scaleBand()只针对`domian()`中的数据集映射相应的值。

```
bandScale(0); //return undefined
```

`scaleBand()`可以通过配置来设定 band 之间的 padding, 这部分可以通过参考 [API](https://github.com/d3/d3-scale/blob/master/README.md#scaleBand)。

### scaleOrdinal()
`scaleOrdinal` 是标准的离散性 scale 函数，输出输出域都使用离散的数据。

```
const ordinalScale = d3.scaleOrdinal()
	.domain(['jack', 'rose', 'john])
	.range([10, 20, 30])
```

映射关系：

![](/images/scaleOrdinal.png)

这个时候的输入输出为：

```
ordinalScale('jack') //return 10
ordinalScale('rose') //return 20
```

那我们来看看，离散性的输入不属于 `domain()` 的数据集时，会发生什么？也会 `return undefined` 吗？不见得。

```
ordinalScale('tom') //return 10
ordinalScale('trump') //return 20
```

可以看出对于离散性的 scale 函数来说，当输入域和输出域不是一一对应时，它会有自己的一套映射规则,就是说，它的输入域是可以隐式增加的，并且会按照顺序循环依次对应`range()`的值。参考[API](https://github.com/d3/d3-scale/blob/master/README.md#ordinal-scales)

# End
还有一些更多的 scale 函数，以及 D3 的 API, 例如事件，例如数组操作，其实用法上跟之前我们学过的一些 JS 方法很相似。希望大家知道了这些概念之后，不只是止步于此。

当然啦，想要继续了解的同学，不要错过我的下一章节。
